# 并发

程序
* 并发程序
    * 并行程序：
        * 一个运行在多处理器上的并发
        * 并行程序是并发程序的真子集
* 顺序程序：一条逻辑流

线程安全的函数：当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果
线程不安全函数类
1. 不包含共享变量的函数
安全措施：使用同步机制：信号量/互斥锁等
2. 保持跨越多个调用的状态的函数（前一次调用影响后一次调用结果）e.g. 伪随机数生成函数rand
3. 返回指向静态变量的指针的函数
安全措施：利用互斥锁定义一个包装的函数
4. 调用线程不安全函数的函数
调用线程不安全函数的函数不一定线程不安全，只有我们对里面的线程不安全函数进行加锁操作，仍然能够得到线程安全的外层函数

可重入函数：
* 不会引用任何共享数据，是线程安全函数的真子集
* 比不可重入的线程安全函数高效，因为他们不需要同步机制

可重入：是否真的可重入，既取决于被调用的函数，也取决于调用者（它传递了什么参数给函数）
* 显式可重入：所以参数都是传值调用，所有数据引用都是本地的自动栈变量
* 隐式可重入：允许参数传递指针，但是必须执行非共享数据


## 并发类型
* 多进程并发
    * 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信IPC方式，在进程间进行信息交换
    * fork使用代价比较高，即使采用写时拷贝，仍然会复制文件描述符/内存页表等多种进程属性，在时间上依然开销大
    * 进程之间的有父子关系，关系不对等。

* 多线程并发
    * 创建线程比创建进程通常要快10倍甚至更多，Linux中，是通过系统调用clone()来实现线程创建的
    * 线程之间时对等关系：线程可以杀死它的任何对等线程或者等待它的任意对等线程终止




任务类型
* 长任务：long-lived tasks
创建专用的线程来处理某些特定任务
* 短任务：short-lived tasks
    * 所需时间短
    * 任务量巨大

线程池的类型
* 计算密集型
* I/O密集型

线程创建具有开销：
* 创建销毁线程需要操作系统时间开销
* 线程有独立的线程栈，占有内存

**为什么需要线程池？？** 线程创建具有开销
你是一个工厂老板(想想都很开心有没有)，手里有很多订单，每来一批订单就要招一批工人，生产的产品非常简单，工人们很快就能处理完，处理完这批订单后就把这些千辛万苦招过来的工人辞退掉，当有新的订单时你再千辛万苦的招一遍工人，干活儿5分钟招人10小时，如果你不是励志要让企业倒闭的话大概是不会这么做到的，因此一个更好的策略就是招一批人后就地养着，有订单时处理订单，没有订单时大家可以闲呆着

**线程池最佳实践**
* 充分理解你的任务，是长任务还是短任务、是CPU密集型还是I/O密集型，如果两种都有，那么一种可能更好的办法是把这两类任务放到不同的线程池中，这样也许可以更好的确定线程数量
* 如果线程池中的任务有I/O操作，那么务必对此任务设置超时，否则处理该任务的线程可能会一直阻塞下去
* 线程池中的任务最好不要同步等待其它任务的结果



