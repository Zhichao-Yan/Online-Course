程序：包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程
* 二进制格式标识：多数 UNIX 实现(包括 Linux)采用可执行ELF连接格式
* 机器语言指令：代码编译后的机器指令
* 数据：变量初始值和程序使用的字面常量
* 程序入口地址：起始指令位置
* 符号表及重定位表：程序中函数和变量的位置及名称，用于调试和运行时的符号解析
* 共享库和动态链接信息：程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名

如何执行程序：内核使用exec函数将程序读入内存，执行程序


进程的内存空间逻辑布局：
* argv和environment变量
    * argv:程序运行的命令行参数
    * environment:环境变量
        * 以名称=值的方式保存
        * 子进程会默认继承父进程的环境变量
* 文本：程序代码段
    * 程序代码段具有只读属性
    * 可以父进程和子进程共享
* 初始化数据段：包含显式初始化的全局和静态变量
* 未初始化的数据段：未显式初始化的全局和静态变量，也称BSS段
* 堆：动态分配内存
* 栈：动态增长和收缩的段
    * 为每个当前调用的函数分配一个栈帧
        * 函数局部变量和函数实参
        * 函数调用的链接信息：在被调用函数的栈帧中保存调用所在函数的指令寄存器的副本
        ```C++
        int main()
        {
            func();// 执行func()函数调用时，指令寄存器保存int a = 5的指令地址
            // func()的栈帧保存指令寄存器的副本，以便func调用返回时继续执行int a = 5;
            int a = 5;
        }
        ```
    * 栈驻留在内存的高端并向下增长
    * 专用寄存器—栈指针(stack pointer)用于跟踪当前栈顶
    * 栈的区分
        * 用户栈
        * 内核栈
            * 保留在内核内存中的内存区域
            * 执行系统调用的过程中供(内核)内部函数调用使用



进程的信息
* 真实用户id和组id：标识用户所属的用户和组
* 有效用户id和组id：进程在访问受保护资源(文件和进程间通信对象)时会，使用这两个ID来确定访问权限
    * 一般情况下，进程的有效ID与相应的真实ID值相同
    * 改变进程的有效ID实为一种机制，可使进程具有其他用户或组的权限。
* 父进程ppid
    * `pid_t getppid(void)`获取父进程号
    * 从`/proc/PID/status`中获取父进程号 e.g. 查看进程号为115的父进程号`/proc/115/status`
* 进程pid
    * `pid_t getpid(void)`获取进程号，数据类型为pid_t
    * 出了特殊的进程（如init进程，id=1），进程和进程号没有固定的关系
    * 新进程创建时，会把下一个可用的进程号分配给


### 特殊进程
* 特权进程：有效用户ID为 0(超级用户)的进程，通常由内核所施加的权限限制对此类进程无效
* init进程：所有进程之父
* 守护进程daemon：e.g. syslogd/httpd
    * 守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在
    * 守护进程在后台运行，且无控制终端供其读取或写入数据

### 进程时间度量
* 进程时间：clock_t保存
    * 时钟时间/墙上时钟时间：进程实际的时间总量，包括进程等待的时间，因此其值与系统中同时运行的进程数有关
    * CPU时间：实际运行CPU指令的时间
        * 用户CPU时间：执行用户指令所用的时间量
        * 系统CPU时间：进程执行内核程序所经历的时间
* 历史时间：自1977年1月1日00:00:00以来经过的秒数，用time_t保存

### 进程创建：使用系统调用fork来创建新进程
* 子进程会获得父进程所有文件描述符的副本，指向相同的打开文件句柄
* 父进程中：fork()返回子进程的进程号，返回-1表示无法创建子进程
* 子进程中：fork()返回0,接下来：
    1. 要么执行与父进程共享代码段段的另一部分函数代码
    2. 要么使用系统调用execve()加载并执行一个新的程序
* fork内存语义：
    * 早期Unix：创建子进程，会父进程程序段、数据段、堆段以及栈段创建拷贝，但是太浪费
        * 程序段随着exec()函数执行，新程序替换进程代码段，重新初始化其 数据段、堆段和栈段
    * 现代Unix：
         内核(Kernel)将每一进程的代码段标记为只读，从而使进程无法修改自身代码。无法修改就能够方便共享。
        * fork()在为子进程构建的一系列进程级页表项,均指向与父进程相同的物理内存页帧,实现共享
        * 对于父进程数据段、堆段和栈段中的各页，内核采用写时复制技术.内核会捕获所有父进程或子进程针对这些页面的修改企图，并为将要修改的页面创建拷贝
* 特殊版本：
导致一些难以察觉的程序缺陷(bug)，除非能给性能带来重大提升
(这种情况发生的概率极小)，否则应当尽量避免使用这一调用。

### 进程终止：0表示正常退出，非0表示异常退出
* 进程自己终止exit()，请求退出，传递进exit()的参数称为进程的“退出状态”
* 其他进程向进程传递信号，根据信号类型来设置进程的终止状态。

* 如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程





3. 进程控制
有3个用于进程控制的主要函数:fork、exec和waitpid. 