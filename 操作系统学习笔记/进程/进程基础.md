**程序**：包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程
* 二进制格式标识：多数 UNIX 实现(包括 Linux)采用可执行ELF连接格式
* 机器语言指令：代码编译后的机器指令
* 数据：变量初始值和程序使用的字面常量
* 程序入口地址：起始指令位置
* 符号表及重定位表：程序中函数和变量的位置及名称，用于调试和运行时的符号解析
* 包含调试信息的段
* 共享库动态链接信息：程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名

如何执行程序：内核使用exec函数将程序读入内存，执行程序


进程的信息
* 真实用户id和组id：标识用户和用户所属的组
    * `uid_t getuid(void);`返回实际用户id
    * `gid_t getgid (void);`返回实际组id
* 有效用户id和组id：进程在访问受保护资源(文件和进程间通信对象)时会，使用这两个ID来确定访问权限
    * 一般情况下，进程的有效ID与相应的真实ID值相同
    * 改变进程的有效ID实为一种机制，可使进程具有其他用户或组的权限。
    * `uid_t geteuid (void);`返回有效用户id
    * `gid_t getegid (void);`返回有效组id
* 父进程ppid
    * `pid_t getppid(void)`获取父进程号
    * 从`/proc/PID/status`中获取父进程号 e.g. 查看进程号为115的父进程号`/proc/115/status`
* 进程pid
    * `pid_t getpid(void)`获取进程号，数据类型为pid_t
    * 除了特殊的进程（如init进程，id=1），进程和进程号没有固定的关系
    * 新进程创建时，会把下一个可用的进程号分配给它
    * 进程id可以复用，但是延迟复用算法保持它近期不会被复用
* 进程组：
    * 定义：多个进程组合一个组，通常是一个作业中共同作用的多个进程
    * 创建进程组的目的：方便信号接收同一进程组中的各进程接收来自同一终端的各种信号
    * 进程组id：pid_t `getpgrp (void);`
    * 进程组可以有一个组长进程：进程组的组长角色，组长进程的id等于进程组id
    * 只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关
    * 进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期
* 特殊进程
    * 系统调度进程id=0，负责进程调度，通常由内核所施加的权限限制对此类进程无效
    * 系统init进程id=1，负责系统的自启
        * 所有进程之父，如果子进程的父进程终止，则子进程就会变成“孤儿”，init进程随即将收养该进程
        * 启动时读取/etc/rcx.d（系统有关的初始化文件）
        * init进程决不会终止，直到系统关机
    * 页守护进程id=2,负责支持虚拟内存分页操作
* 守护进程daemon：e.g. syslogd/httpd
    * 守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在
    * 守护进程在后台运行，且无控制终端供其读取或写入数据

* 进程时间：clock_t保存`time`命令
    * 时钟时间/墙上时钟时间：进程实际的时间总量，包括进程等待的时间，因此其值与系统中同时运行的进程数有关
    * CPU时间：实际运行CPU指令的时间
        * 用户CPU时间：执行用户指令所用的时间量
        * 系统CPU时间：进程执行内核程序所经历的时间
* 历史时间：自1977年1月1日00:00:00以来经过的秒数，用time_t保存



**进程的内存空间逻辑布局** 
* argv和environment变量：
    * argv:程序运行的命令行参数
    * environment:环境变量
        * 以名称=值的方式保存
        * 子进程会默认继承父进程的环境变量
    * 该段空间无法增长：情况比较复杂
* 文本：程序代码段
    * 程序代码段具有只读属性
    * 可以父进程和子进程共享
* 初始化数据段：包含显式初始化的全局和静态变量
* 未初始化的数据段：未显式初始化的全局和静态变量，也称BSS段，
    * 不会包含在磁盘程序文件中，因为不包含初始值，内核在执行时自动初始化为0
    * 没有初始值不占有空间，留在磁盘程序文件中的只有变量符号表
* 堆：用于动态分配内存
    * 大多数malloc和free不改变进程内存空间大小，释放后将它们保持在malloc池中不返回给内核
    * 大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息-内存块长度和指向下一块的指针
    * 致命malloc错误
        * free了不是动态分配的指针
        * 再次释放了free过了的指针
        * 忘记释放分配的指针
* 栈：动态增长和收缩的段
    * 为每个当前调用的函数分配一个栈帧
        * 函数局部变量和函数实参
        * 函数调用的链接信息：在被调用函数的栈帧中保存调用所在函数的指令寄存器的副本
        ```C++
        int main()
        {
            func();// 执行func()函数调用时，指令寄存器保存int a = 5的指令地址
            // func()的栈帧保存指令寄存器的副本，以便func调用返回时继续执行int a = 5;
            int a = 5;
        }
        ```
    * 栈驻留在内存的高端并向下增长
    * 专用寄存器—栈指针(stack pointer)用于跟踪当前栈顶
    * 栈的区分
        * 用户栈
        * 内核栈
            * 保留在内核内存中的内存区域
            * 执行系统调用的过程中供(内核)内部函数调用使用
    * 实现栈帧之间的跳转setjmp()/longjmp()



### 进程创建
#### 进程启动
* 进程包含一个启动例程：
    * 调用main之前会调用特殊的启动例程，这是程序的起始地址
    * 启动例程获取命令行参数和环境变量
    * 启动例程使用命令行参数调用main函数`exit(main(argc,argv));`


#### 子进程创建
* fork()函数
    * 父进程中：fork()返回子进程的进程号，返回-1表示无法创建子进程
    * 子进程中：fork()返回0,子进程操作
        1. 要么执行与父进程共享代码段段的另一部分函数代码
        2. 要么使用系统调用execve()加载并执行一个新的程序
            * exec函数不创建新进程，用新程序替换了当前进程的正文段、数据段、堆段和栈段
            * exec是一个函数族，有7种不同的exec函数
    * fork内存语义：
        * 早期Unix：创建子进程，会父进程程序段、数据段、堆段以及栈段创建拷贝，但是太浪费
            * 程序段随着exec()函数执行，新程序替换进程代码段，重新初始化其数据段、堆段和栈段
        * 现代Unix：
            * 内核(Kernel)将每一进程的代码段标记为只读，从而使进程无法修改自身代码。方便共享。
            * fork()在为子进程构建的一系列进程级页表项,均指向与父进程相同的物理内存页帧,并且只可以读，实现共享
            * 对于父进程数据段、堆段和栈段中的各页，内核采用写时复制技术.内核会捕获所有父进程或子进程针对这些页面的修改企图，并为将要修改的页面创建拷贝

* 父进程和子进程共享
    * 子进程会拷贝父进程所有文件描述符的副本，指向相同的打开文件句柄
    * 程序文本上：如果子进程不调用execv()，那么子进程和父进程共享同一段程序文本
    * 栈/堆/全局内存如果采用写时拷贝，子进程和父进程暂时共享，
    * 资源限制？？
    * 共享存储段？？
    * 存储映像？？
    * 环境变量？？
    * 信号屏弊和安排？？
    * 当前工作目录/根目录
    * 实际用户id/组id 有效用户id/组id
    * 进程组id
    * 会话id？？
    * 控制终端？？
* 父进程和子进程不同
    * 进程id不同
    * 各自父进程id不同
    * fork()返回值不同
    * 如果不写时拷贝的话，栈/堆/全局内存子进程和父进程相互独立


* 函数vfork()
    * 目的：用于创建一个新进程，而该新进程的目的是exec一个新程序
    * 区别：保证子进程先运行，调用exec和exit后父进程才重新调度执行
    * 缺陷：可能死锁的情况，如果子进程依赖于父进程


* 特殊版本：
导致一些难以察觉的程序缺陷(bug)，除非能给性能带来重大提升
(这种情况发生的概率极小)，否则应当尽量避免使用这一调用。



### 进程终止 

**进程终止状态/退出状态** 
* 终止状态为其他如-1
    * return -1
    * exit(-1)/_exit(-1)/_Exit(-1)
* 终止状态为0
    * 返回类型为整数，且return 0
    * 调用exit(0)/_exit(0)/_Exit(0)
* 终止/退出状态未定义
    * main函数返回类型非整数如void返回
    * main执行无返回值return
    * 调用exit()/_exit()/_Exit()不带参数

**检查进程终止状态**：`echo $?`打印终止状态

**进程自愿终止的方法**：显式或者隐式调用_exit或Exit终止
1. 隐式地间接通过调用exit()，然后调用_exit或Exit终止
    * 首先调用exit()
        * 显式调用exit():在成员函数/main函数中显式调用exit()
        * 隐式调用:return返回到例程中，例程中使用return返回值调用exit()
        `exit(main(argc,argv));`
    * 调用exit()后：
        1. 执行终止处理程序，终止程序函数由atexit()登记，exit()执行，
            * 终止处理程序由atexit()进行登记
                * 参数是一个函数地址，无需参数，无需返回值
            * exit函数自动执行终止处理程序，执行顺序和登记顺序相反
            * 多次登记，多次调用
        2. 调用标准I/O清理程序
        3. 调用_exit()/_Exit()进入内核
2. 显式直接调用_exit()/_Exit()，调用后立即进入内核


**进程非自愿终止的方法**
* 其他进程向进程传递信号，根据信号类型来设置进程的终止状态。


#### 进程正常终止
1. 从main返回-》在例程中调用exit()
2. 调用exit()->处理完终止处理程序调用_exit()/_Exit()返回内核
3. 调用_exit()/_Exit()，直接返回内核
4. 最后一个线程从启动例程返回
5. 量后一个线程调用pthread_exit

#### 进行异常终止
6. 调用abort()，自身产生SIGABRT信号终止，这是下面的特例，自身产生一个信号
7. 接受一个信号
    * 若进程引用地址空间之外的存储单元
    * 除0发出SIGFPE信号
    * 键盘ctrl+c等同于kill发出SIGINT信号
    * kill命令发出SIGINT信号
    * 自身abort()发出SIGABRT信号
8. 最后一个线程对取消请求做出响应


* 进程终止时，父子进程关系
    * 如果父进程先于子进程终止：子进程被init进程收养
        * 内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程
        * 如果是，该进程的父进程改为id=1，保证每个子进程都有父进程
    * 如果子进程先于父进程终止：
        1. 如果子进程完全消失，那么父进程无法获取子进程终止状态，因此内核为每个终止子进程保存了一定量的信息，所以终止后子进程不是完全消失，还保留一些信息---僵尸进程
            * 子进程id
            * 子进程终止状态：终止的子进程通知其父进程关于它的终止状态
                * 对于正常终止：退出状态传递给exit/_exit/_Exit函数
                * 对于异常终止：内核产生一个指示其异常终止原因的终止状态
            * 子进程CPU使用量
        2. 终止进程的父进程调用wait或waitpid时，返回终止子进程id
        获取信息后，内核释放终止进程所使用的所有存储区，关闭其所有打开文件
        * `pid_t wait(int *statloc)`
            * 当前存在子进程终止，并且是僵尸进程，父进程取得子进程终止状态后立即返回
            * 当前没有终止的子进程，wait阻塞父进程，直到一个子进程终止
            * 如果没有子进程，则出错返回
        * `pid_t waitpid(pid_t pid,int *statloc,int options)`
            * `pid = -1` 等待任意子进程，等价于wait
            * `pid > 0` 等待进程id=pid的进程
            * `pid = 0` 等待子进程的**组id**和调用进程的**组id**相同的任意子进程
            * `pid < -1` 等待子进程的进程组id等于**pid绝对值**的任意子进程
        * waitpid和wait区别
            1. 通过设置waitpid的`options = WNOHANG`，实现子进程并没有终止，但是调用者不阻塞，waitpid返回0
            2. waitpid可以等待任意特定进程，而wait等待所有子进程
            3. waitpid通过option常量`WCONTINUED｜WUNWUNTRACED`支持作业控制
        * **僵尸进程**：己经终止、但是其父进程尚未对其进行善后处理



 

