### 操作系统构成
* 系统内核
    * 内核的位置：Linux上位于`/boot/vmlinuz`
    * 内核的功能：管理和分配计算机资源的的核心软件
        * 中断服务程序
        * 进程管理:进程的调度/进程创建/进程终止/进程挂起等
        * 内存管理：通过虚拟内存管理机制给系统一种拥有更大内存的幻觉
        * 文件系统管理:通过虚拟文件系统能够实现通过不同类型的文件系统从硬盘中读写数据
        * 设备管理：实现内核和设备的通信
            * 实现：通过设备驱动程序作为中间人允许内核与设备之 间交换数据
            * 内核中插入驱动的办法
                * 将设备驱动代码编译到内核：每次添加设备都有编译内核，很麻烦
                * 使用内核模块：随用随插，无需重新编译
            * 设备类型
                * 块设备 e.g. 硬盘
                * 字符设备 e.g. 终端
                * 网络设备 e.g. 网卡和回环设备
    * 内核的状态
        * 系统态
            * 应用程序在内核空间执行
            * 可以访问受保护的内存空间
            * 访问硬件设备的所有权限
        * 用户态
            * 应用程序在用户空间执行
            * 只能访问自己的内存空间
            * 使用特定的系统功能和资源
            * 不能直接访问设备
    * 内核实现策略
        * 单内核/宏内核：
            * 使用：
                * 大多数Unix系统内核为宏内核
                * Linux内核属于创新的宏内核：模块可以插入移除到内核，模块的热插拔和动态装载得以实现
            * 特点：
                * 单个静态二进制文件的形式存放于磁盘。即全部子系统如内存管理/设备驱动/文件系统 打包到一个文件
                * 运行在一个单独的地址空间上，内核可以直接相互调用函数，每个函数可以访问内核中的其他部分，因此内核之间通信很方便
            * 优点：简单性能高
            * 缺点：出错冗余度不高
        * 微内核：实际上应用中不让任何微内核服务器运行在用户空间，这违背了微内核设计初衷
            * 使用于：Windows NT（window-xp/win7/window vista）和MacOS
            * 特点
                * 内核被划分多个独立的进程，每一个进程保持独立并运行在各自的地址空间上
                * 最基本功能委托给中央内核进程实现，其他功能委托给一些运行于用户空间的独立进程
                    * 不能直接调用函数，而是需要通过IPC机制
            * 优点：
                1. 系统组件划分清晰，方便程序设计
                2. 模版化设计避免一个服务出错影响其他服务
                2. 具有动态扩展性，能够运行时切换组件
            * 缺点：组件之间支持复杂通信需要额外的CPU成本，IPC开销大，周期长（涉及上下文切换）
        * 外内核

* 应用软件：
    * 软件
        * 系统软件：
            * 桌面环境GNOME/KDE/Unity
            * GNU coreutils
                * Shell程序：Shell是一种特殊的应用软件，为运行其他程序提供一个接口
                    * 单个命令执行
                        * 执行内置shell命令
                        * 执行非内置shell命令，查找并执行对应程序
                    * 多个命令执行：制作shell脚本
                    * 系统自带多种shell：zsh/ash/tcsh等，Linux会采用一个作为默认
                * 二进制命令程序：ls/rm/kill/cat/chmod等
        * 用户软件：办公软件/工业软件/文本处理软件等
    * 基本工作方式：应用程序通过系统调用界面陷入内核
    * 具体：应用程序通常通过调用库函数调用系统调用，然后让内核代其完成不同的任务。
        * 复杂库函数简单包含系统调用：系统调用只是整个步骤的一部分而已
        e.g. printf()函数实现了数据格式化和缓存，而调用write()系统调用写到控制台只不过是一部分动作而已
        * 简单库函数就是简单的系统调用
        e.g. open()库函数简单调用open()系统调用
        * 库函数不使用系统调用
        e.g. strcpy()库函数

* 系统内核和应用软件的接口：系统调用
